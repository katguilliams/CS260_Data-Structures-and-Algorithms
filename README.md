# CS260_Data-Structures-and-Algorithms
# Unit 7 Final Project Reflection Paper

  For this project I am a programmer at Southern New Hampshire University Software. The customers for this program are managers of eBid Nashville who are looking for a program that will allow its users to access information on the items that are sold through the eBid website. This process is done by adding a search algorithm to the program that will allow users to access the different information on the items the users sell or buy using the eBid website.
  
  The knowledge I have on data structures is limited but still growing with every project. Data structures are defined as a group of data gathered under a single name. The first project I chose to start with was the module 3 LinkedList assignment. The linked list data structure is close to having all requirements for this section on this project. The LinkedList assignments code shows a data structure as a list of data under one name, which is what the LinkedList code is about. The LinkedList code lets us store a list of items that have the same type of date or datatype by using the array data structure.
  
  Vectors are data structures that programmers use to store data that is based of lines or arcs. These vectors are defined by having a beginning point and end points which will meet using the nodes. In the LinkedList program you can see the vectors being represented as it separates the lists data along with the list by using a vector to compact the data structure.
  
  Hash Tables are structures of data that can store items that are not in order by hashing each variable to a specified location in a vector. Doing this helps reduce the time searching through the data for specific items. With hashing we can store the data using hash functions which allows the hashing to respond faster to search results and find the searched item faster as well. Hashing data sometimes uses a structure that is encrypted, like an encryption used for some websites, but the main use of the hash tables and the hashing method is for searching for items in a list. We can use hash tables to store the rest of the data that vectors are unable to store. 
  
  Tree structures are built like coded trees. Binary trees are made of nodes that contain a right and a left with the data while the top node is called the root. Using a binary tree for a search algorithm runs smoother and faster than the previous search algorithms. The binary tree search algorithms are better for getting search results faster than lists. This is because the tree algorithm has a root, like a real tree, along with children being the branches of the tree. The search can divide and conquer because the answer that is being searched for is either on one of the children to the left of the tree or on one of the children to the right of the tree. During the search, the algorithm is set to search one side of the tree first and if the answer is not on the searched side than it will search the other side. Coding a tree algorithm does take some time and can be hard to execute but it is worth it in the end. For example, if a list of data you have is around 10,000 nodes long it may need 10,000 comparisons but these nodes in a tree algorithm could only need 14 comparisons. Instead of the algorithm searching through the list one by one, it will search one side and then the other. If the answer is on the first side searched, the search will be completed.
  
  Algorithms are made up of steps that break down tasks into smaller steps allowing the code to process the commands easily. A recursive algorithm is one of these algorithms that can be used in the program. For example, if a program was made to feed animals the algorithm can break the steps down. The first step would be to grab the food dishes for the animals, the second would be to put the specified food in the dish for each animal, and the third would be placing the dishes where the animals normally eat. These are the three main steps needed to feed animals, while there are more steps in the process, this is what the algorithm would break it down to. In module five of this class, the program coded was specifically for searching and sorting vectors using hash/chaining methods in a Hash Table.
  
  Search algorithms work based on a given set of data. The data starts being searched at the top of the list, checking each line of data before moving to the next, until the specific data that is being searched for is found or until the list ends. In the coding assignment for module five, a search part of the code is written to allow the code to search for a return bid. This is done by the algorithm starting at the top of the data on a graph or table and goes down until the search criteria is met.
  
  Sorting algorithms allow the data to be sorted in any order that the user needs. This could be in ascending or descending order alphabetically or numerically. The user could want the data to be sorted by the name of each listing or by the number of each listing. This can take a while as the data is not fully viewed by the code so it will go in the given order for each listing to sort the data. For example, if the data is being sorted alphabetically in ascending order, the data could have a lot of data that is out of place. This will take the sorting algorithm a while depending on how much data is listed. This is where hash tables come in. Building a hash table in the algorithm allows the search to work faster and be more stable.
  
  In hashing/chaining there is a hash function that maps nodes to certain values. These may lead to a collision or two where there are two or more nodes mapped to the same value. Chaining is used to avoid these collisions. Chaining allows each part of a hash table to have its own value to prevent collisions in the code and in the hash table. One of the tasks in module fives program is to create this code that allows us to create a chain hash to avoid collision.
  
  My best, or favorite, program that uses both an algorithm and a data structure is the program from module six where we were tasked with creating working binary tree algorithms. I chose this assignment because it includes both data structure and algorithms along with showing how far I have come in understanding what I have learned throughout this course. This code also shows the binary tree search algorithm in depth. In the module six code assignment we were asked to create a Binary Tree program that uses methods in the programming interface used to interact with a hash table.
  
  The module six code assignment shows a lot of what is learned throughout this course and combines different elements from each module of the course into one assignment. This assignment did have a few pieces of code missing from the start, but after coding five other assignments prior to this one it was easy to realize that the code that was missing was at the very beginning where you tie in different codes into this source code. For example, the code on line 289 was giving errors no matter what edits were made to the code. This is because in line 11 at the beginning of the code was blank and was not made to incorporate algorithms into the code. After incorporating algorithms and the commands recognized by algorithms was inputted, the code began to work with no errors.
  
  Most coding assignments throughout the course of this class allowed the programmer to re-use areas of the code in different places with little or no edits in the copied code and the code would work the way it needs to. The way I built this coding assignment is the same way, the code could be reused in a different place and be edited to work with that line of data to make that section of code work. Module six gave most of the code that was needed to complete the code along with the data needed to run the code smoothly. The module six code assignment had more annotations throughout the code than previously coding assignments throughout the course have and the code looks neater and easier to read. This shows me that I have progressed in not only being able to read the code and understand what is needed in other places of the code but also that I can annotate the code accordingly and keep the code clean to the point where reviewing the code will not be a hassle.
  
  This course has taught me a lot about coding in C++ to the point where I can carry on a conversation about the code and be able to understand what I am saying along with what is being said or pointed out to me. I have learned how to keep code organized, annotated, and reusable. Using the Eclipse program as the main program that allows me to code these assignments has made the process easy. I learned how to add different packages in the Eclipse program that made the edits needed to allow me to code in both Java and C++ in different projects. A previous class I took used the Eclipse program but for the Java coding language and when starting this class, I was relieved to find out that the Eclipse program included a package to incorporate the C++ coding language as well. When trying to download different versions of the Eclipse program went wrong, this class taught me how to add the C++ package to the existing Eclipse program on my computer. This allowed me to have side projects in Java accessible in Eclipse at the same time of coding programs in C++ for assignments in this class. This class taught me about the different search algorithms that are used in coding and how to create these algorithms in a set of code using the data given for that code.
  
  Data structures are important when it comes to developing computer programs. These data structures help organize the code and allow the code to be stored properly. There are different versions of data structure, primitive and abstract. The primitive data structure is not as complex as the abstract data structure. Abstract data structures hold more complex types of data like queues, linked lists, trees, etc. While the primitive data structure holds certain types of data that are mostly char, floats, integers, etc.
  
  Algorithms are a big part of any code where there is data that needs to be searched or sorted through. There are many different algorithms, whether it is finding the data, sorting the data, or even deleting the data after finding it. Each algorithm has a different time frame that it uses to implement the code. For example, there are many ways to write an algorithm to search for specific data. Binary trees happen to be faster search algorithms that are used compared to other search algorithms like linked lists.
  
  My goal after getting through college and graduating with a bachelor’s degree is to become a software developer. This leads me down the path of needing to learn different coding languages, data structures, algorithms, the whole nine yards. This class has helped me learn how to code in C++ and know more about different algorithms that can be used to sort data. This is information I will need to know when creating software in the future. I have played around with coding small projects here and there but did not know enough to make a full working program. I am slowly on my way to finishing my first program and learning these algorithms has helped me add on to that program.
